from neo4j import GraphDatabase
import os
import json
from topicCreate import generate_learning_roadmap # Import your AI function
from Source_gen import generate_sources_for_topic # NEW: Import the source generator

# --- Neo4j Connection Details ---
# Store these securely, e.g., in environment variables or a config file
URI = "bolt://localhost:7687" # Default Bolt port
USERNAME = "neo4j"
PASSWORD = os.getenv("NEO4J_PASSWORD", "your_neo4j_password") # IMPORTANT: Use env var in production

driver = None # Initialize driver globally or pass it around

def get_neo4j_driver():
    global driver
    if driver is None:
        try:
            driver = GraphDatabase.driver(URI, auth=(USERNAME, PASSWORD))
            driver.verify_connectivity()
            print("Neo4j connection successful!")
        except Exception as e:
            print(f"Failed to connect to Neo4j: {e}")
            driver = None
    return driver

def close_neo4j_driver():
    global driver
    if driver is not None:
        driver.close()
        driver = None
        print("Neo4j driver closed.")

# Always ensure the driver is closed when your application shuts down.
# For a web app, use Flask/FastAPI's teardown hooks.

def create_topic_node(tx, topic_data):
    # Create or merge the Topic node
    # MERGE is used to ensure idempotency: if the topic already exists, it won't create a duplicate
    query = """
    MERGE (t:Topic {id: $id})
    ON CREATE SET
        t.title = $title,
        t.description = $description,
        t.difficulty_level = $difficulty_level
    ON MATCH SET
        t.title = $title,
        t.description = $description,
        t.difficulty_level = $difficulty_level
    RETURN t
    """
    tx.run(query,
           id=topic_data['id'],
           title=topic_data['title'],
           description=topic_data['description'],
           difficulty_level=topic_data['difficulty'])

def create_prerequisite_relationships(tx, topic_id, prerequisite_ids):
    # Create relationships for prerequisites
    # Ensure prerequisite topics exist before creating relationships
    query = """
    MATCH (currentTopic:Topic {id: $currentTopicId})
    UNWIND $prerequisiteIds AS prereqId
    MATCH (prereqTopic:Topic {id: prereqId})
    MERGE (prereqTopic)-[:PREREQUISITE_FOR]->(currentTopic)
    """
    tx.run(query, currentTopicId=topic_id, prerequisiteIds=prerequisite_ids)

def create_source_nodes_and_relationships(tx, topic_id, sources_data):
    # Create Source nodes and link them to the Topic
    for source in sources_data:
        query = """
        MATCH (t:Topic {id: $topicId})
        MERGE (s:Source {url: $url})
        ON CREATE SET
            s.type = $type,
            s.relevance_score = $relevance_score,
            s.title = $title
        ON MATCH SET
            s.type = $type,
            s.relevance_score = $relevance_score,
            s.title = $title
        MERGE (t)-[:HAS_SOURCE]->(s)
        """
        tx.run(query,
               topicId=topic_id,
               url=source['url'],
               type=source['type'],
               relevance_score=source['relevance_score'],
               title=source['title'])
# --- User-Specific Data (for later, but design it now) ---
def update_user_topic_status(tx, user_id, topic_id, status, mastery_score):
    # User node will need to be created/merged first
    query = """
    MERGE (u:User {id: $userId})
    ON CREATE SET u.created_at = datetime()
    MATCH (t:Topic {id: $topicId})
    MERGE (u)-[s:STUDIES]->(t)
    SET s.status = $status, s.mastery_score = $mastery_score, s.updated_at = datetime()
    """
    tx.run(query, userId=user_id, topicId=topic_id, status=status, mastery_score=mastery_score)

def create_topic_connection(tx, user_id, topic1_id, topic2_id, strength):
    # This relationship models the "virtual brain" connection.
    # It's probably best as a directed relationship from topic1 to topic2 if topic1 "leads" to topic2.
    # Or an undirected relationship if the connection is mutual.
    # Let's assume directed from topic1 to topic2, where topic1 is the "source" of the connection idea.
    query = """
    MATCH (t1:Topic {id: $topic1Id}), (t2:Topic {id: $topic2Id})
    MERGE (t1)-[c:RELATES_TO]->(t2)
    SET c.strength = $strength, c.updated_by_user = $userId, c.updated_at = datetime()
    """
    tx.run(query, userId=user_id, topic1Id=topic1_id, topic2Id=topic2_id, strength=strength)


def ingest_roadmap_into_neo4j(learning_goal: str, user_id: str):
    driver = get_neo4j_driver()
    if not driver:
        print("Cannot ingest roadmap, Neo4j driver not available.")
        return

    # 1. Generate topics using AI
    ai_generated_topics = generate_learning_roadmap(learning_goal) # Call your AI function

    if not ai_generated_topics:
        print("No topics generated by AI. Aborting ingestion.")
        return

    # --- IMPORTANT: Data Cleaning/Validation Step ---
    unique_topics = {}
    for topic in ai_generated_topics:
        if topic['id'] not in unique_topics:
            unique_topics[topic['id']] = topic
        else:
            print(f"Warning: Duplicate topic ID found: {topic['id']}. Skipping or merging.")

    cleaned_topics = list(unique_topics.values())
    # --- END Data Cleaning/Validation ---

    with driver.session() as session:
        # First pass: Create all Topic nodes
        print("Creating topic nodes...")
        for topic_data in cleaned_topics:
            session.execute_write(create_topic_node, topic_data)
        print("Topic nodes created.")

        # Second pass: Create relationships and sources
        print("Creating prerequisite relationships and and sources...")
        for topic_data in cleaned_topics:
            # Create prerequisite relationships
            if topic_data.get('prerequisites'):
                session.execute_write(create_prerequisite_relationships, topic_data['id'], topic_data['prerequisites'])

            # NEW: Generate and ingest sources for each topic
            sources_for_topic = generate_sources_for_topic(topic_data)
            if sources_for_topic:
                session.execute_write(create_source_nodes_and_relationships, topic_data['id'], sources_for_topic)
                print(f"  Ingested {len(sources_for_topic)} source(s) for '{topic_data['title']}'.")
            else:
                print(f"  No sources generated for '{topic_data['title']}'.")
            # END NEW

        print("Prerequisite relationships and sources (if applicable) created.")

    print(f"Roadmap for '{learning_goal}' ingested into Neo4j.")

if __name__ == "__main__":

    learning_goal_input = input("What would you like to learn? ")
    current_user_id = "user123" # This would come from your user authentication system

    ingest_roadmap_into_neo4j(learning_goal_input, current_user_id) #ingesting the data into neo4j


    # Example of how you might query the graph after ingestion
    driver = get_neo4j_driver()
    if driver:
        with driver.session() as session:
            print("\nTopics in the database:")
            result = session.run("MATCH (t:Topic) RETURN t.id, t.title ORDER BY t.id LIMIT 10")
            for record in result:
                print(f"- {record['t.id']}: {record['t.title']}")

            # Find a topic and its direct prerequisites
            print("\nPrerequisites for 'tailwind_layout' (example):")
            result = session.run("""
                MATCH (prereq:Topic)-[:PREREQUISITE_FOR]->(current:Topic {id: 'tailwind_layout'})
                RETURN prereq.title
            """)
            for record in result:
                print(f"- {record['prereq.title']}")

            # NEW: Query to find topics and their linked sources (with titles)
            print("\nTopics and their sources in the database (first 10):")
            result = session.run("""
                MATCH (t:Topic) OPTIONAL MATCH (t)-[:HAS_SOURCE]->(s:Source)
                RETURN t.title, COLLECT({url:s.url, type:s.type, title:s.title}) AS sources
                ORDER BY t.title LIMIT 10
            """)
            for record in result:
                print(f"- {record['t.title']}")
                for source in record['sources']:
                    if source['url']: # Check if source is not null
                        print(f"  Source: {source['url']} (Type: {source['type']}) - Title: {source['title']}")
                print("-" * 20)
            # END NEW

        close_neo4j_driver()