from neo4j import GraphDatabase
import os
import json
from topicCreate import generate_learning_roadmap # Import your AI function

# --- Neo4j Connection Details ---
# Store these securely, e.g., in environment variables or a config file
URI = "bolt://localhost:7687" # Default Bolt port
USERNAME = "neo4j"
PASSWORD = os.getenv("NEO4J_PASSWORD", "your_neo4j_password") # IMPORTANT: Use env var in production

driver = None # Initialize driver globally or pass it around

def get_neo4j_driver():
    global driver
    if driver is None:
        try:
            driver = GraphDatabase.driver(URI, auth=(USERNAME, PASSWORD))
            driver.verify_connectivity()
            print("Neo4j connection successful!")
        except Exception as e:
            print(f"Failed to connect to Neo4j: {e}")
            driver = None
    return driver

def close_neo4j_driver():
    global driver
    if driver is not None:
        driver.close()
        driver = None
        print("Neo4j driver closed.")

# Always ensure the driver is closed when your application shuts down.
# For a web app, use Flask/FastAPI's teardown hooks.

def create_topic_node(tx, topic_data):
    # Create or merge the Topic node
    # MERGE is used to ensure idempotency: if the topic already exists, it won't create a duplicate
    query = """
    MERGE (t:Topic {id: $id})
    ON CREATE SET
        t.title = $title,
        t.description = $description,
        t.difficulty_level = $difficulty_level
    ON MATCH SET
        t.title = $title,
        t.description = $description,
        t.difficulty_level = $difficulty_level
    RETURN t
    """
    tx.run(query,
           id=topic_data['id'],
           title=topic_data['title'],
           description=topic_data['description'],
           difficulty_level=topic_data['difficulty'])

def create_prerequisite_relationships(tx, topic_id, prerequisite_ids):
    # Create relationships for prerequisites
    # Ensure prerequisite topics exist before creating relationships
    query = """
    MATCH (currentTopic:Topic {id: $currentTopicId})
    UNWIND $prerequisiteIds AS prereqId
    MATCH (prereqTopic:Topic {id: prereqId})
    MERGE (prereqTopic)-[:PREREQUISITE_FOR]->(currentTopic)
    """
    tx.run(query, currentTopicId=topic_id, prerequisiteIds=prerequisite_ids)

def create_source_nodes_and_relationships(tx, topic_id, sources_data):
    # Create Source nodes and link them to the Topic
    for source in sources_data:
        query = """
        MATCH (t:Topic {id: $topicId})
        MERGE (s:Source {url: $url})
        ON CREATE SET
            s.type = $type,
            s.relevance_score = $relevance_score,
            s.summary = $summary
        ON MATCH SET
            s.type = $type,
            s.relevance_score = $relevance_score,
            s.summary = $summary
        MERGE (t)-[:HAS_SOURCE]->(s)
        """
        tx.run(query,
               topicId=topic_id,
               url=source['url'],
               type=source['type'],
               relevance_score=source['relevance_score'],
               summary=source['summary'])

# --- User-Specific Data (for later, but design it now) ---
def update_user_topic_status(tx, user_id, topic_id, status, mastery_score):
    # User node will need to be created/merged first
    query = """
    MERGE (u:User {id: $userId})
    ON CREATE SET u.created_at = datetime()
    MATCH (t:Topic {id: $topicId})
    MERGE (u)-[s:STUDIES]->(t)
    SET s.status = $status, s.mastery_score = $mastery_score, s.updated_at = datetime()
    """
    tx.run(query, userId=user_id, topicId=topic_id, status=status, mastery_score=mastery_score)

def create_topic_connection(tx, user_id, topic1_id, topic2_id, strength):
    # This relationship models the "virtual brain" connection.
    # It's probably best as a directed relationship from topic1 to topic2 if topic1 "leads" to topic2.
    # Or an undirected relationship if the connection is mutual.
    # Let's assume directed from topic1 to topic2, where topic1 is the "source" of the connection idea.
    query = """
    MATCH (t1:Topic {id: $topic1Id}), (t2:Topic {id: $topic2Id})
    MERGE (t1)-[c:RELATES_TO]->(t2)
    SET c.strength = $strength, c.updated_by_user = $userId, c.updated_at = datetime()
    """
    tx.run(query, userId=user_id, topic1Id=topic1_id, topic2Id=topic2_id, strength=strength)


def ingest_roadmap_into_neo4j(learning_goal: str, user_id: str):
    driver = get_neo4j_driver()
    if not driver:
        print("Cannot ingest roadmap, Neo4j driver not available.")
        return

    # 1. Generate topics using AI
    # This will be your `roadmap` from the previous step.
    ai_generated_topics = generate_learning_roadmap(learning_goal) # Call your AI function

    if not ai_generated_topics:
        print("No topics generated by AI. Aborting ingestion.")
        return

    # --- IMPORTANT: Data Cleaning/Validation Step ---
    # Before ingesting, process ai_generated_topics to handle duplicates and ensure data integrity.
    # This is where your deduplication logic (as discussed in previous responses) goes.
    # For simplicity, let's assume `ai_generated_topics` is already cleaned.
    # Example: a basic deduplication (you'll need more robust logic)
    unique_topics = {}
    for topic in ai_generated_topics:
        if topic['id'] not in unique_topics:
            unique_topics[topic['id']] = topic
        else:
            # You might want to merge information from duplicates here if needed
            print(f"Warning: Duplicate topic ID found: {topic['id']}. Skipping or merging.")

    cleaned_topics = list(unique_topics.values())
    # --- END Data Cleaning/Validation ---

    with driver.session() as session:
        # First pass: Create all Topic nodes
        # We create all nodes first to ensure prerequisites can reference them
        print("Creating topic nodes...")
        for topic_data in cleaned_topics:
            session.execute_write(create_topic_node, topic_data) # Changed to execute_write
        print("Topic nodes created.")

        # Second pass: Create relationships and sources
        print("Creating prerequisite relationships and sources...")
        for topic_data in cleaned_topics:
            # Create prerequisite relationships
            if topic_data.get('prerequisites'):
                session.execute_write(create_prerequisite_relationships, topic_data['id'], topic_data['prerequisites']) # Changed to execute_write

            # Create source nodes and relationships (if you have source data from AI or another process)
            # For initial topic generation, the AI likely won't provide sources directly.
            # This step would come after you implement your source generation/linking.
            # For now, let's add a placeholder for sources.
            # simulated_sources = [
            #       {"url": f"https://example.com/source/{topic_data['id']}_1", "type": "Website", "relevance_score": 0.9, "summary": f"Summary for {topic_data['title']} source 1"},
            #       {"url": f"https://youtube.com/video/{topic_data['id']}_2", "type": "Video", "relevance_score": 0.8, "summary": f"Summary for {topic_data['title']} source 2"},
            # ]
            # session.execute_write(create_source_nodes_and_relationships, topic_data['id'], simulated_sources) # Changed to execute_write
        print("Prerequisite relationships and sources (if applicable) created.")

        # Optionally, create/merge the User node (e.g., for the current session user)
        # You'd likely have user creation/auth elsewhere.
        # session.execute_write(lambda tx: tx.run("MERGE (:User {id: $userId})", userId=user_id))

    print(f"Roadmap for '{learning_goal}' ingested into Neo4j.")

if __name__ == "__main__":

    learning_goal_input = input("What would you like to learn ")
    current_user_id = "user123" # This would come from your user authentication system

    ingest_roadmap_into_neo4j(learning_goal_input, current_user_id) #ingesting the data into neo4j


    # Example of how you might query the graph after ingestion
    driver = get_neo4j_driver()
    if driver:
        with driver.session() as session:
            result = session.run("MATCH (t:Topic) RETURN t.id, t.title ORDER BY t.id LIMIT 10")
            print("\nTopics in the database:")
            for record in result:
                print(f"- {record['t.id']}: {record['t.title']}")

            # Find a topic and its direct prerequisites
            print("\nPrerequisites for 'tailwind_layout':")
            result = session.run("""
                MATCH (prereq:Topic)-[:PREREQUISITE_FOR]->(current:Topic {id: 'tailwind_layout'})
                RETURN prereq.title
            """)
            for record in result:
                print(f"- {record['prereq.title']}")

        close_neo4j_driver()